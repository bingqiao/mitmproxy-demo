# WTTR with regular and reverse proxies
Now we deploy both regular and reverse proxies with wttr.

## WTTR
This simple golang app now is proxy awrae and exposes port 18080.

If environment variables `http_proxy` and `https_proxy` are set, the app will use their values to set up proxy for http client.
## Docker
The most important changes to `docker-compose.yaml` include:
1. adding a `mitmproxy` container as regular proxy
2. adding a `mitmproxy-r` container as reverse proxy
2. setting two environment valriables `http_proxy` and `https_proxy` on `wttr` container, and
3. adding a shared volume so `wttr` container has in the right location the certificate generated by `mitmproxy` upon startup. Notice both proxy containers share the same volume too so the reverse proxy will use certificates generated by the regular proxy (which starts first), without generating a different set of certificates on its own. This is purely for the convenience of clients and is not a must-have.

Run the app:
```
docker-compose up
```
Notice there is a folder named `mitmproxy` created under `1-mitmproxy-regular`. This folder is volume mounted to mitmproxy container and is used by mitmproxy to store generated certificates.

## Tests
* Open the web UI for `mitmproxy` reverse proxy in browser at `http://localhost:8081`.
* Open the web UI for `mitmproxy` regular proxy in browser at `http://localhost:9081`.

Test 1, request to `localhost:18080`, success expected:
```
curl "http://localhost:18080/?loc=Reading"
```
This request goes directly to `wttr` app without going through reverse proxy.
* Observe this request doesn't show up in the web UI of reverse proxy `http://localhost:8081`
* Observe the request sent by `wttr` to `wttr.in` shows up in the web UI of regular proxy `http://localhost:9081`

Test 2, request to `localhost:8080` (reverse proxy), success expected:
```
curl "http://localhost:8080/?loc=Reading"
```
This request goes through reverse proxy first and the enusing request from `wttr` to `wttr.in` goes through the regular proxy.
* Observe this request shows up in the web UI of reverse proxy `http://localhost:8081`
* Observe the request sent by `wttr` to `wttr.in` shows up in the web UI of regular proxy `http://localhost:9081`

Now lets grab the certificate:
```
docker cp mitmproxy-r:home/mitmproxy/.mitmproxy/mitmproxy-ca-cert.pem ./mitmproxy-ca-cert.pem
```

Test 3, request to `localhost:8080` (reverse proxy) with SSL and expects success:
```
curl "https://localhost:8080/?loc=Reading" --cacert ./mitmproxy-ca-cert.pem
```
Observe a new request shows up in the web UI for both regular and reverse proxies.

Test 4, request to `wittr.in`, proxied by the regular proxy and expect success:
```
curl "https://wttr.in/Reading?0" --proxy localhost:9080 --cacert ./mitmproxy-ca-cert.pem
``` 
This request goes directly to the external `wttr.in` site without going through either `wttr` app or the reverse proxy.
* Observe this request doesn't show up in the web UI of reverse proxy `http://localhost:8081`
* Observe the request to `wttr.in` shows up in the web UI of regular proxy `http://localhost:9081`

N.B. this certifcate was copied from the reverse proxy but it works against the regular proxy because as mentioned above both proxies share the same set of certificates via the shared volume.

Ctrl+C to stop the docker compose. Then do the clean up:
```
docker-compose down
```

# Kubernetes
If you haven't run `docker-compose up`, run the following to build the docker image first:
```
docker buildx build -t wttr-proxied .
```
The docker image needs to be made availabe to the Kubernetes cluster. For a local Kind cluster, this is done by:
```
kind load docker-image wttr-proxied:latest --name k8s-dev
```
You can check if the image has been loaded correctly by:
```
docker exec -it k8s-dev-control-plane crictl images
```
Deploy `wttr-proxied` app, `mitmproxy` and `mitmproxy-reverse` to local cluster `k8s-dev`:
```
kubectl apply -f deployment.yaml
```
Check the new pod is up and running without error:
```
kubectl get pods
```
Open up another terminal and set up port-forward so the wttr cluster service `wttr-service-double-proxied` just deployed can be accessed at port 18080 (mapped to wttr container) from local host:
```
kubectl port-forward service/wttr-service-double-proxied 18080:18080
```
Open up another terminal and set up port-forward so the wttr cluster service `wttr-service-double-proxied` just deployed can be accessed at port 9080 (mapped to mitmproxy container for regular proxy) from local host:
```
kubectl port-forward service/wttr-service-double-proxied 9080:9080
```
Open up another terminal and set up port-forward so the wttr cluster service `wttr-service-double-proxied` just deployed can be accessed at prot 9081 (mapped to mitmproxy container for regular proxy web UI) from local host:
```
kubectl port-forward service/wttr-service-double-proxied 9081:9081
```
Open up another terminal and set up port-forward so the wttr cluster service `wttr-service-double-proxied` just deployed can be accessed at port 8080 (mapped to mitmproxy-reverse container for reverse proxy) from local host:
```
kubectl port-forward service/wttr-service-double-proxied 8080:8080
```
Open up another terminal and set up port-forward so the wttr cluster service `wttr-service-double-proxied` just deployed can be accessed at prot 8081 (mapped to mitmproxy-reverse container for reverse proxy web UI) from local host:
```
kubectl port-forward service/wttr-service-double-proxied 8081:8081
```
## Tests
* Open the web UI for `mitmproxy` reverse proxy in browser at `http://localhost:8081`.
* Open the web UI for `mitmproxy` regular proxy in browser at `http://localhost:9081`.

Test 1, request to `localhost:18080`, success expected:
```
curl "http://localhost:18080/?loc=Reading"
```
This request goes directly to `wttr` app without going through reverse proxy.
* Observe this request doesn't show up in the web UI of reverse proxy `http://localhost:8081`
* Observe the request sent by `wttr` to `wttr.in` shows up in the web UI of regular proxy `http://localhost:9081`

Test 2, request to `localhost:8080` (reverse proxy), success expected:
```
curl "http://localhost:8080/?loc=Reading"
```
This request goes through reverse proxy first and the enusing request from `wttr` to `wttr.in` goes through the regular proxy.
* Observe this request shows up in the web UI of reverse proxy `http://localhost:8081`
* Observe the request sent by `wttr` to `wttr.in` shows up in the web UI of regular proxy `http://localhost:9081`

Now lets grab the certificate:
```
kubectl cp -c mitmproxy wttr-double-proxied:root/.mitmproxy/mitmproxy-ca-cert.pem ./mitmproxy-ca-cert.pem
```

Test 3, request to `localhost:8080` (reverse proxy) with SSL and expects success:
```
curl "https://localhost:8080/?loc=Reading" --cacert ./mitmproxy-ca-cert.pem
```
Observe a new request shows up in the web UI for both regular and reverse proxies.

N.B. this certifcate was copied from the regular proxy container but it works against the reverse proxy because as mentioned above both proxies share the same set of certificates via the shared volume.

Test 4, request to `wittr.in`, proxied by the regular proxy and expect success:
```
curl "https://wttr.in/Reading?0" --proxy localhost:9080 --cacert ./mitmproxy-ca-cert.pem
``` 
This request goes directly to the external `wttr.in` site without going through either `wttr` app or the reverse proxy.
* Observe this request doesn't show up in the web UI of reverse proxy `http://localhost:8081`
* Observe the request to `wttr.in` shows up in the web UI of regular proxy `http://localhost:9081`

Ctrl+C to stop the all three port-forward termnimal then run the following to cleanup:
```
kubectl delete -f deployment.yaml
```

This concludes the final part of this tutorial.